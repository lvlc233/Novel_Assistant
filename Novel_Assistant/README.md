# Novel_Assistant
This is a multi-agent novel-writing assistant. While you converse with an intelligent AI, you can create your story—and it remembers your habits, co-authoring with you every step of the way. This project is my graduation thesis and a gift for a dear friend.
# 补充:
  项目还在持续进行,暂时不可直接运行
# 介绍:
该系统由三大个Agent组成,分别是:
  - 门面Agent
    主要与用户交互的Agent,提供`沟通`,`文档读写`,`任务分配:(推荐生成,记忆,KD)的调控`的任务。
  - 记忆Agent
    负责
    - 长期记忆整理
    - 工作记忆生成
    - 记忆相关的存储与读取操作
  - 知识Agent
    负责
    - 
尽管在项目中你们会发现有许多的LLM调用,但是总的来说,这些模型都是为了构建这三个核心的Agent而存在
# 架构说明
注意,该结构中的内容随时可能会发生增加、修改或者减少,但总的来说如图所示。
其中左边蓝色的区域为`门面Agent`相关的模块,右边两块白色的部分分别是`记忆Agent`和`知识Agent`相关的模块,最右边,是基础建设相关。
### 名词解释
**上下文(Context)**：这里的上下文就是指交给LLM的上下文，包括长期记忆、工作记忆和短期记忆。  
其中，长期记忆和短期记忆由专门的模块进行处理，处理完成后将会交还给*上下文(Context)*，并将其转意为LLM可识别的消息。  
长期记忆和短期记忆在数据结构上共同由于*反思、知识、场景*组成，知识库索引指向指向了知识库笔记缓存，当有需要的时候才会从缓存中获取具体的笔记。

**短期记忆(Short-Term Memory)**：完整的上下文窗口，包含和用户和Agent的互动全过程。  
在系统中，`短期记忆`具有一定缓存，当`短期记忆`上下文窗口过于长时，将会自动转化为`工作记忆`，这个过程是异步的，也即是用户无感知的。  
当`工作记忆`转化完成时，将会移除部分`短期记忆`。

**工作记忆(Work Memory)**：由短期记忆而来，通过`记忆Agent`将`短期记忆`处理为具有不同特征的压缩上下文。  
在减少上下文的长度的时候确保关键信息不会丢失，当`工作记忆`过长时，会进一步的压缩`工作记忆`使其维持在一个合理的信息密度之中。  
注意，尽管从`上下文`的角度看，记忆是被覆盖的，但是后台会持续存放着，并将利用这些数据，在合适的时候将他们转化为`长期记忆`。

**长期记忆(Long-Term Memory)**：最紧密的内容，通常存储用户最关注的信息，同样由`记忆Agent`生成。  
不同于`短期记忆`和`工作记忆`随着会话而发生改变，`长期记忆`将持续的应用在您使用项目的整个生命周期里，除非您主动将其重置。

**记忆类型(Memory Type)**：这里还是先解释下记忆和知识库的差距在哪？  
实际上，不论是LangMem，还是Mem0，个人认为和RAG具有及高的相似度。从技术上都使用到了向量化，图化等，从手段和目的上看，但是在必要的时候从外部数据源中获取上下文信息。  
就RAG原始的含义(检索，增强，生成)来说，记忆也是一种RAG，要说相对来说比较明显的差异的话，那应该是静动态的差别，记忆能根据运行来动态的增加数据，而一般的RAG更加倾向于静态的数据准备。  
尽管如此。要想区别记忆和知识库从技术上看确实是不太明了的事情。因此换个角度，从目的的角度上去思考，或许会清晰很多。  
这里个人给出的解释是：记忆，关注和用户交互过程中的经验，其旨在更好的提升用户的体验，知识库，关注专业数据本身，从Agent的角度上来说，记忆确实是大脑中的内容，而知识库，更应该像是Agent使用的笔记。

- **反思记忆**：Agent和用户交互的"感情"记忆，Agent会反思过去的交互中和您发生的一切事情，并关注到那些它做的好的，做得不好的地方，以便其可以实时调整自己的行为。

- **知识记忆**：用其他框架的内容来说，应该叫`语义记忆`，在当前阶段两者保持等意，都是强调话语中实体，事实，关系，概念等含义的记忆，或者用一句话来解释，关键词与关键记忆。

- **场景记忆**：同样延续了其他框架的内容，强调和用户交流过程中的大致过程，具有时间要素和前后关系。

**知识数据(Knowledge Data)**：可被检索的并存入模型上下文中的专业知识数据，例如医疗系统中的数据...在这里，特指在系统中创建的文档例如小说。

**知识数据索引(Knowledge Data Index)**：当`上下文`中的知识库数据超过一定规模将主动退化为索引，索引指向实际的`知识数据`，而`知识数据`存储在缓存中，当有需要的时候再优先从缓存中获取，缓存的结构为`被检索关键词:指向缓存的位置`。

**知识数据缓存(Knowledge Data Cache)**：用于暂时存储`知识数据`，会话无关，直到程序重启或者主动清除。

### 结构图
<img width="2088" height="1173" alt="image" src="https://github.com/user-attachments/assets/a27a0408-8362-4ac3-9b55-25f092239d66" />



# 代码结构
## 后端部分
```
src
├── api
├── common
│   ├── config
│   ├── context.py
│   ├── decorator.py
│   ├── memory.py
│   ├── models
│   ├── prompts.py
│   ├── store.py
│   └── utils.py
├── core
│   └── agent
└── main.py
```

# 技术栈
### 前端(尚未开始)
  - react.js
  - Next.js
### 后端
  - Lang Graph
  - Lang Chain
  - pg
  - neo4j
  - milvus
# 更新日志
**`当前进度`**:已经初始化整个项目结构,主要有三个模块:`agents`,`common`,`utils`

- 其中`agents`:存储可独立运行的Agent,当前有完成了`提示词推荐Agent(未整理)`, `记忆管理Agent(初步最简单demo)`,`门面Agent(没开始xixi)`,每一个Agent包包括`state`:用于存储`状态`,`LLM格式输出器`。`node`:用于节点和工具,`graph`:图的构建。

- 其中`common`:存储系统的支撑建设及其定义,包括`context(上下文)`,`KD(知识数据)`,`memory(记忆)`,`prompts(存储提示词)`,`store(持久化相关的)`

- 其中`utils`:存储一些通用工具。

补充:上述`conmmon`模块可能会在后续的版本中有比较大的更新

**`已完成内容`**:
- `utils`中的雪花id生成
- `common`中的`store`的抽象定义(解耦表,操作和客户端)、定义了基础的CRUD的操作枚举、定义了长期,短期,工作记忆,KD索引和文档的表定义、sqlite,pg的具体实现。
- `common`中的`prompts`初步定义推荐Agent的提示词(待优化),反思、语义和场景提取的提示词(待优化),
- `common`中的`model_load`的初定义,用于实现用户高可以配的模型定义
- `common`中的`memory`中的基础、反思、知识和场景记忆的定义-->注意,长短期记忆等这是相对于上下文而存在的。5
- `common`中的`KD`的初定义(极简)
- `common`中的`context`的初定义
- `agents`中的`提示词推荐Agent`初完成
- `agents`中的`记忆管理Agent`初完成


**`下一步计划`**:
- 打通`memory`、`store`和`记忆管理Agent`
- 初步实现`门面Agent`



