# 项目规格文档

## 项目介绍
这个项目是一个小说管理和创作的+AI的面向作者的小说创作平台。该项目旨在让Agent融入传统小说创作平台的全流程中，利用环境感知，上下文管理工程和资源管理技术，为任意的创作者提供全流程的，一站式的小说创作服务，旨在降低创作者在创作过程中的创作性质心智负担(例如章节管理,角色梳理,版本管理等问题。)，全身心的投入在有价值的内容产出中。
 **注意**: 本文档提供高层次的项目指导。

所有开发工作应以文档为事实来源。


## 项目架构
### 后端
1. 3+1层架构: 
    - controller层: 
        1. 负责service层数据到web层数据的封装。
        2. 负责权限相关处理。
        3. 该层还负责定义请求相关的数据模型。
    - service层: 
        1. 负责核心数据合成
        2. 负责调度基础设施层: 包括redis,sql,neo4j等
    - 基础设置层:
        1. 提供相关基础设施的操作语句的封装。
    - 数据层:
        1. 该层仅存放数据模型而不进行任何的逻辑处理。
        2. 数据层的数据模型应从业务逻辑出发构建，并由于service层进行组装。

这个项目不做身份权限等验证,没有登录和注册的内容。
3. 在web层的所有数据模型统一使用Pydantic而非TypeDict
4. 使用fastApi的容器管理线程资源，并给予注入传递线程信息。


### Agent:
定义: 在本项目中，Agent指独立的一个已编译的图。
#### 状态
1. 任何的状态统一使用TypeDict为基类，而非dataclass或BaseModel
2. 任何的状态都应该至少保留两个字段:
    "messages": 该字段用于面向用户的历史信息记录，任何情况下Agent的上下文不应该直接使用messages中的任意的数据，除非它经过处理或在其他字段中存储。
    "context":  该字段用于面向Agent的上下文信息，包括但不限于历史交互记录。该字段通常不是用户直接可以查询的内容。
3. 所有的Message都必须使用langchain的Messages类进行包装而不能直接使用字典{"role":"","message":""}
4. 必须备注状态中的所有字段的含义、作用，使用范围。
5. 当状态使用归约函数(特征是使用Anntion[type,func]进行标记的字段),则在处理状态时
6. 当一个字段需要在运行时候发生改变时，它应该是状态,如messages

#### 工具
1. 所有的工具都应该尽量功能内聚,并提供明确的工具调度实机，参数细节，预期返回结构，异常信息潜在情况。
2. 当工具信息需要更新状态时候，使用Command包装工具的返回值，并且在更新字段时必须至少携带{"messages": ToolMessages("工具调度的消息{自定义}",tool_call_id=tool_call_id)}
3. tool_call_id通过节点注入runtime:ToolRuntime,runtime.tool_call_id获取。
4. 所有的工具不论具体的逻辑是什么，在返回时至少需要更新模型的上下文状态，并传入信息工具的调用结果
5. 所有工具必须考虑异常情况的捕获和异常时的上下文处理

#### 模型上下文
1. 所有的上下文都必须携带时间信息
2. 上下文数据的封装必须在调度模型的节点处进行动态的拼装，所有非自然语言数据结构(如 类等)必须转化为自然语言或带有数据格式(如.md...)的上下文信息。
3. 当上下文数据中携带字段时，不论什么情况都应该对字段进行含义的解释后，传入上下文。
4. 当上下文中存在对话历史记录等，必须将消息明确的区分为 用户: "" | 时间,Agent_name: "" | 时间
5. 所有的上下文必须明确当前处理的Agent是什么Agent，所属任务是什么。

#### 静态上下文 与 config配置
1. 所有的静态上下文仅可以使用可序列化数据模型，而不应该在静态上下文中存储不可序列化的数据,例如: client_session_id: ok,clinet: can`t 
2. 如果需要将不可以序列化实例传入节点或工具内部，应该使用config进行注入和获取。
3. 当一个字段不需要在运行时候发生改变时，它应该是静态上下文: 如user_id


#### 记忆
1. Agent的长期记忆部分由节点的store注入获取。

#### 节点
1. 所有的节点返回时候使用字典的方式进行所需状态字段的更新，而非返回一个状态对象。 
2. 所有节点必须考虑异常情况的捕获和异常时的上下文处理
3. 使用Command进行节点跳转时,必须使用Literal[...],约束跳转目标节点。在add_node中设置ends,用于辅助美人鱼图生成。

#### 输出
1. 图的输出使用astream监听事件
2. 可监听类型为:token,tool和自定义。
3. 使用from langgraph.config import get_stream_writer 获取写入器进行自定义的事件写入。

#### 人工介入
当存在需要人工介入时逻辑时，如内容审核、外部状态注入，进行以下分析
1. 强人工介入，图的数据必须由于Human进行数据的输入或确定后才可以进行后续流程时，使用interrupt函数进行中断抛出，注意langgraph的中断恢复后将从节点从重新执行而非在中断函数处继续。
2. 强人工介入需要返回相关的语句提示，并在接收端至少包括一个用户输入内容，用于人类进行自然语言的任务编排。
3. 弱人工介入, 需要人工介入的数据不影响图的正常运行，例如一些待办事项、todo列表。使用时候不基于interrupt函数进行中断，而是在状态中建立一个代办项管道。用户可以通过Command操作更新管道数据。从而进行人工介入。

#### 测试
Agent测试内容包括3个部分，并以节点和工具为单位。
1. 单节点或工具功能性测试:
使用pytest对节点的输入输出测试，使用mock数据校验节点的输入数据，输出数据，和内部数据状态，使其完全符合节点内的功能和实现描述。
2. 模型测试:
- 当一个节点包含LLM时，应该对其进行模型的测试，需要分析在节点内容潜在上下文状态，并创建可能的上下文数据(包括工具结果)，对不同的上下文数据进行实际的LLM调用，以确保其最终的实际输出结果符合大致预取。
- 模型的测试中所有需要获取转化为上下文的数据都可以进行mock，但是模型的输出不可以mokc
- 使用langfuse进行链路追踪
- 在生成潜在上下文时，标注测试节点、测试内容、预期结果。并将其封装为数据集的一部分。
- 模型测试包含功能性测试和规格性测试: 规格性测试表示模型需要输出符合实际描述的数据结构，这通常可以使用断言判断，功能性测试是指模型的输出最终要符合要求，例如指令遵循程度，抗干扰程度，通常使用一个审核Agent或人类进行打分。
3. 级联测试，
- 基于实际可能的交互过程，对Agent进行非mock数据的全面测试。
- 需创建数据集
- 使用langfuse进行链路追踪


### 前端
1. **架构与框架**:
    - 采用 **Next.js 14 (App Router)** 架构，充分利用 Server Components 进行性能优化。
    - 核心语言: **TypeScript 5+**，强制开启严格模式。
    - 路由策略: 基于文件系统的路由 (File-system based routing)，遵循 `src/app` 目录结构。

2. **UI/UX 设计体系**:
    - 样式引擎: **Tailwind CSS**，实现原子化、可响应的样式开发。
    - 组件库: 基于 **Radix UI** (Headless UI) + **Shadcn/UI** 的自建组件体系，确保可定制性与无障碍访问 (A11y)。
    - 图标库: 使用 **Lucide React**。

3. **核心功能模块实现**:
    - 富文本编辑: TipTap富文本编辑
    - AI信息处理: Vercel AI SDK


4. **状态管理与数据流**:
    - **客户端状态**: 使用 **Zustand** 管理轻量级全局状态 (如 UI 开关、用户会话、阅读器配置)。
    - **服务端数据**: 优先使用 Next.js Server Actions 与 Server Components Fetching；统一封装请求层处理拦截与错误映射。

5. **配置与环境**:
    - 使用 `next.config.mjs` 处理构建配置。
    - 环境变量通过 `.env` 管理，禁止硬编码敏感信息。




## 技术总览(可选但推荐)

> 基于 `uv` 构建的 AI 小说创作助手。

---

### 1. 后端
| 组件 | 版本/说明 | 作用 |
|---|---|---|
| Python | ≥3.12.x | 主语言 |
| uv | latest | 包管理 + 虚拟环境 + 构建（替代 pip/poetry） |
| FastAPI | latest | 异步 Web 框架，自动生成 Swagger |
| Uvicorn | latest | ASGI 服务器 |
| sse-starlette | latest | SSE 流式输出 |
| psycopg2-binary | latest | PostgreSQL 驱动 |
| sqlmodel | latest | ORM，与 Pydantic 无缝集成 |
| PyJWT | latest | JWT 签发/校验 |
| httpx | latest | 异步 HTTP 客户端 |
| loguru | latest | 统一日志格式：时间戳｜输入｜输出｜异常 |

---

### 2. 前端
| 组件 | 版本/说明 | 作用 |
|---|---|---|
| Next.js | 14+ (App Router) | 全栈框架，路由与SSR |
| TypeScript | 5.x | 静态类型系统 |
| TailwindCSS | latest | 原子化样式引擎 |
| Shadcn/UI | latest | 基于 Radix UI 的组件库 |
| TanStack Query | v5 | 服务端状态管理 |
| Tiptap | laster | 富文本编辑器 |
| Vercel AI SDK | v5 | 大模型客户端SDK |
| Zustand | latest | 客户端全局状态管理 |


---

### 3. AI / ML
| 组件 | 版本/说明 | 作用 |
|---|---|---|
| LangChain | ≥1.1.0 | LLM 编排：Chain、Memory、Tool |
| LangGraph | ≥1.0.0 | 图结构多 Agent 工作流 |
| SiliconFlow | — | 大模型运营商，统一 OpenAI-Compatible API |
---

### 4. 数据与检索
| 组件 | 版本/说明 | 作用 |
|---|---|---|
| PostgreSQL | ≥15 | 主关系型数据库 |
| Redis | 7.x | 缓存、分布式锁、SSE 会话 |
| Neo4j | latest | 图数据库，知识图谱 |
| Whoosh + Jieba | latest | 纯 Python 全文检索 + 中文分词 |

---

### 5. 工具链
| 组件 | 版本/说明 | 作用 |
|---|---|---|
| uv | latest | 极速依赖管理、构建、发布 |
| Ruff | latest | Rust 级代码检查/格式化 |
| Git + GitHub Actions | — | CI/CD，可复现构建（基于 `uv.lock`） |

---

## 代码实现的规范
1. 所有的功能模块都应该使用日志
2. 所有的代码模块都必须记录完整的日记，
3. 设置时间区域为中国上海
4. 当一个非业务逻辑的函数或相似的逻辑被构建超过3次，那么它应该考虑合并为通用的工具，例如获取当前的中国时区时间。
5. 项目中所有的数据必须标注好其返回的数据类型。
6. 在一个功能没有经过测试验证后，必须始终保持TODO的状态，
7. 禁止使用任何的模拟数据用于暂时替代代码逻辑。若表示需要更加明确的逻辑，则使用TODO进行位置标注，并附加需求。
8. 所有人编写代码时候必须附加上以下数据格式的注释，否则将被视为不符合规范
    '''
    开发者: agent_name/ human_name
    当前版本: 任何一个在该模块不重复的标记
    创建时间: 使用YYYY-MM-DD 时:分格式,Agent使用Time工具获取当前时间
    更新时间: 使用YYYY-MM-DD 时:分格式,Agent使用Time工具获取当前时间
    更新记录: 
        [开发时间:开发版本:用一句话大概描述下输入,输出,效果,实现,可以在什么地方使用?]
    '''
9. 如果一个模块打算废弃，使用 废弃的注解标志，并提交废弃申请记录，供MasterAgent或人类审核。 
10. 后端项目始终使用模块化导包而非相对位置导包，若不清楚模块内容，查看pyproject.toml文件。

## 数据模型设计规范（SaaS化哲学）
核心原则：数据模型即业务边界。模型是模块间交互的契约，而非全局共享的数据容器。

1. **显式契约 (Explicit Contracts)**
   - 任何功能模块（Module/Service/Function）必须显式定义其 `Input` 和 `Output` 模型（通常使用 Pydantic BaseModel 或 TypedDict）。669+
   - 禁止使用 `dict` 或 `Any` 作为公开接口的参数或返回值，必须强类型化。

2. **禁止透传 (No Pass-through)**
   - **数据库实体隔离**：Dao 层的数据库实体（Entity, 如 `UserORM`）**严禁**直接作为 Controller 层的 Response 输出。必须在 Service 层转换为业务模型（DTO）。
   - **层级解耦**：Web 层的 Request/Response 模型仅在 Controller 层可见。Service 层的 Input/Output 模型仅在 Service 层及调用者间可见。

3. **模型下沉 (Colocation)**
   - 推荐将特定模块使用的模型定义在模块内部（如 `modules/paper/schema.py`），而非全部堆积在全局的 `common/models`。
   - 仅当模型在多个完全不相关的模块间复用时，才放入 `common` 包。

4. **SaaS 化思维**
   - 开发任何模块时，将其视为一个独立的 SaaS 服务。
   - 问自己：如果我要把这个模块拆分成微服务，我的输入输出是否足够清晰？

## 项目目录结构 (2026-01-15)

### Backend
```text
backend/
├── alembic/              # 数据库迁移脚本
├── src/
│   ├── api/              # API 接口层 (Routes, Exception Handlers)
│   ├── common/           # 通用模块 (Log, Utils, Global Errors)
│   ├── core/             # 核心模块 
│   │   ├──  agents/      # Agent相关的内容(Agents, Runtime, State)
│   │   └──   models.py   # 通用数据模型
│   ├── infrastructure/   # 基础设施层 (Database, External Clients)
│   └── services/         # 业务服务层 (Business Logic)
├── .gitignore
├── alembic.ini           # Alembic 配置
├── pyproject.toml        # 项目依赖与配置
├── README.md
└── run.py                # 启动入口
```

目前阶段: 数据库和api接口已对齐,后续将无法修改,也不应该数据库数据模型和api接口,如果遇到无法轻松实现的功能,要及时的通知管理员而非进行service过度的封装或修改。以进行数据结构的调整。