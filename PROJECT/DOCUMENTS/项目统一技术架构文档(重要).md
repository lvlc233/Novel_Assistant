# 项目统一技术架构文档 (Unified Technical Architecture)

> **版本**: v1.1
> **日期**: 2026-01-21
> **提交方**: masterAgent
> **状态**: 更新 (Updated)
> **说明**: 本文档作为项目开发的唯一技术事实来源 (Single Source of Truth)，统一插件化、Agent 编排与前后端接口约定。

---

## 1. 系统架构概览

采用 **前后端分离** + **插件化能力** + **Agent 编排** 的架构。

- **前端**: Next.js 14 (App Router) + Zustand + TailwindCSS + Radix UI + Tiptap
- **后端**: FastAPI + SQLModel + PostgreSQL (pgvector)
- **Agent**: LangGraph + LangChain 1.1+（create_agent 与中间件）
- **插件运行时**: 能力注册表 + UI 插槽 + 命令系统

### 架构原则
1. 核心最小化，插件优先扩展
2. 事件/命令驱动，插件之间不直接耦合
3. 可中断与可恢复，支持人工介入
4. 可观测与可审计，统一日志与追踪
5. 版本兼容与能力声明，保持可持续演进

---

## 2. 前端技术选型与需求
### 技术选型
| 模块 | 选型 | 理由 |
| :--- | :--- | :--- |
| **框架** | **Next.js 14+ (App Router)** | SSR/SSG 支持完善，路由一致性强。 |
| **语言** | **TypeScript 5.x** | 类型安全与可维护性提升。 |
| **样式** | **TailwindCSS** | 原子化样式体系，迭代速度快。 |
| **组件库** | **Radix UI + 自建组件（Shadcn 风格）** | Headless UI 便于复杂交互组合。 |
| **图标** | **Lucide React** | 轻量统一。 |
| **图表** | **Reagraph** | 知识图谱可视化需求。 |
| **状态管理** | **Zustand** | 轻量高性能。 |
| **AI 交互** | **fetch + eventsource-parser（SSE）** | 兼容流式输出与中断。 |
| **Tiptap 渲染** | **tiptap** | 富文本编辑能力稳定。 |
| **消息提示** | **Sonner** | 轻量统一提示。 |
| **请求发送** | **Axios（封装 request.ts）** | 统一鉴权与错误处理。 |
| **SSE增强** | **@microsoft/fetch-event-source** | 支持自定义 Header 与 POST 流式。 |

### 前端关键能力
- 插件 UI 插槽与面板布局
- 命令系统与快捷键
- 文档 patch 应用与冲突提示
- SSE 流式渲染与中断处理
- 插件启停与权限提示

---

## 3. 后端技术选型与需求
### 技术选型
| 模块 | 选型 | 理由 |
| :--- | :--- | :--- |
| **框架** | **FastAPI** | 异步友好，接口规范清晰。 |
| **ORM** | **SQLModel** | 类型安全与模型一致性。 |
| **数据库** | **PostgreSQL + pgvector** | 结构化数据与向量检索兼容。 |

### 后端关键能力
- 插件注册、启停与权限控制
- 作品/文档/关系数据管理
- 保存与 checkpoint 机制
- AI 调用网关与配额审计
- Agent 会话与线程管理

---

## 4. Agent 技术选型与需求
### 技术选型
| 模块 | 选型 | 理由 |
| :--- | :--- | :--- |
| **编排框架** | **LangGraph** | 状态图编排与持久化执行。 |
| **模型适配** | **LangChain 1.1+** | 多模型与工具调用统一接口。 |

### Agent 关键能力
- StateGraph 与子图复用
- Command 更新状态并动态路由
- interrupt 人工介入与审批
- checkpointer + thread_id 可恢复会话
- astream/astream_events 流式观测

---

## 5. 前后端接口规范
通用前缀: `/api/v1`，以下路径皆省略前缀。

- 统一响应包装: `{code:int,data:T,message:str}`，SSE 流式除外
- 成功时: `code = 200`
- 非业务错误: `code = 50000`
- 业务错误码: `5 位数`
- HTTP status 按标准语义返回，`code` 作为业务分支
- 统一时间格式: ISO-8601
- 对外接口只出现 `*Request/*Response`，内部模型禁止直接作为 Response 字段

---

## 6. 业务模块接口清单
### 插件管理模块 (Plugin): 500xx
#### 接口列表
| Method | Path | Description | Payload/Params | Response |
| :--- | :--- | :--- | :--- | :--- |
| `GET` | `/plugins` | 获取插件列表 |  | `List[PluginMetaResponse]` |
| `GET` | `/plugins/{plugin_id}` | 获取插件详情 |  | `PluginResponse` |
| `PATCH` | `/plugins/{plugin_id}` | 启用或更新配置 | `PluginUpdataRequest` |  |

#### 模型明细
```python

class PluginMetaResponse(BaseModel):
    id:UUID
    name: str
    enabled:bool

class PluginResponse(BaseModel):
    id:UUID
    name: str
    description:str
    enabled:bool
    config:dict
    from_type:Literal["system","custom"] #插件来源类型,系统级别不可删除,自定义插件可删除
    scope_type:Literal["global","work","document"] #插件作用域类型,global全局生效,work和document可以在作品中选择性开启或关闭。
    tags:List[str] #插件标签,用于搜索的

class PluginUpdataRequest(BaseModel):
    enabled:bool = None
    config:dict = None

# 定义的数据模型,仅参考
class PluginDefinitions(BaseModel):
    id:UUID # 插件id
    name: str #插件名
    description: str #插件描述
    enabled: bool #插件是否启用,禁止后,所有的功能全部关闭。
    # TODO:这里可以再分析下。
    config_schema:dict #插件配置schema:key为变量名,value为变量名字的数据结构例如: {"api_key":"string"}, 支持对象
    default_config:dict #插件默认配置参数:key为变量名,value为变量名值例如:{"api_key":"sk-...."},优先级低于自定义的。
    from_type:Literal["system","custom"] #插件来源类型,系统级别不可删除,自定义插件可删除
    scope_type:Literal["global","work","document"] #插件作用域类型,global全局生效,work和document可以在作品中选择性开启或关闭。
    tags:List[str] #插件标签,用于搜索的

class PluginWorkMapping(BaseModel):
    # 用于对work进行更加细致的配置
    id:UUID # 唯一id
    plugin_id:UUID # 配置id,对应上面的id
    work_id:UUID # 作品id
    enabled: bool #插件是否启用,在work中启用后,才会在work中生效。除非其作用等级是global。
    config:dict #插件配置参数:key为变量名,value为变量名值例如:{"api_key":"sk-...."},优先级高于默认的。 

```

### 作品管理模块: 510xx
#### 接口列表
| Method | Path | Description | Payload/Params | Response |
| :--- | :--- | :--- | :--- | :--- |
| `POST` | `/works` | 创建作品 | `CreateWorkRequest` | `WorkMetaResponse` |
| `GET` | `/works` | 获取作品列表 |  | `List[WorkMetaResponse]` |
| `PATCH` | `/works/{works_id}` | 更新作品元信息 | `WorkMetaUpdataRequest` |  |
| `DELETE` | `/works/{works_id}` | 删除作品 |  ||
| `GET` | `/works/{works_id}` | 获取作品详情 |  | `WorkDetailResponse` |
| `GET` | `/works/{works_id}/plugins` | 获取作品插件列表 |  | `List[WorkPluginMetaResponse]` |
| `PATCH` | `/works/{works_id}/plugins/{plugin_id}/enable?enabled={enabled}` | 更新作品插件启动状态  |  |  |
| `GET` | `/works/{works_id}/plugins/{plugin_id}` | 获取作品插件详情 |  | `WorkPluginDetailResponse` |
| `PATCH` | `/works/{works_id}/plugin/{plugin_id}` | 更新作品插件配置 | `UpdateWorkPluginRequest` | |


#### 模型明细
```python
# 在servcie中的DTO(可复用)
class WorkMetaDTO(BaseModel):
    work_id: str
    work_cover_image_url: str | None = None
    work_name: str | None = None
    work_summary: str | None = None
    work_state: Literal["完成", "进行中"] = "进行中" 
    work_type: str
    created_time: datetime
    updated_time: datetime


# 文档关系
class NodeDTO(BaseModel):
    node_id: str
    node_name: str
    description: str | None = None
    node_type: Literal["document", "folder"]
class EdgeDTO(BaseModel):
    from_nodes:List[str]
    to_nodes:List[str]

# controller层的数据模型
class CreateWorkRequest(BaseModel):
    works_cover_image_url: str | None = None # 前端是怎么加载图片的?
    works_name: str | None = None
    works_summary: str | None = None
    works_type: str  # 本质上是插件名->给定了作品内文档的组织形式。| 目前我们只支持小说模式
    enabled_plugin_id_list: List[UUID] = [] # 用户可配置的插件

class WorkMetaResponse(BaseModel):
    work_meta: WorkMetaDTO

class WorkMetaUpdataRequest(BaseModel):
    works_cover_image_url: str | None = None
    works_name: str | None = None
    works_summary: str | None = None
    works_state: Literal["完成", "进行中"] = "进行中" 

class WorkDetailResponse(BaseModel):
    works_meta: WorkMetaDTO
    works_document: List[NodeDTO] = []
    works_documents_relationship: List[EdgeDTO] = []

class WorkPluginMetaResponse(BaseModel):
    plugin_id: UUID
    name: str
    enabled:bool
    description: str

class WorkPluginDetailResponse(BaseModel):
    plugin_id:UUID # 插件id
    name: str #插件名
    description: str #插件描述
    enabled: bool 
    config:dict 
    from_type:Literal["system","custom"] #插件来源类型,系统级别不可删除,自定义插件可删除
    scope_type:Literal["global","work","document"] #插件作用域类型,global全局生效,work和document可以在作品中选择
    tags:List[str] #插件标签,用于搜索的

class UpdateWorkPluginRequest(BaseModel):
    plugin_id: UUID
    enabled: bool 
    config:dict 


```

### 文档管理模块: 511xx
#### 接口列表
| Method | Path | Description | Payload/Params | Response |
| :--- | :--- | :--- | :--- | :--- |
| `POST` | `/works/{works_id}/documents` | 创建文档 | `DocumentCreateRequest` | `DocumentResponse` |
| `DELETE` | `/works/{works_id}/documents/{document_id}` | 删除文档 |  |  |
| `PATCH` | `/works/{works_id}/documents/{document_id}` | 更新文档 | `DocumentUploadRequest` |  |
| `GET` | `/works/{works_id}/documents/{document_id}` | 获取文档详情 |  | `DocumentDetailResponse` |
| `POST` | `/works/{works_id}/node` | 创建节点,也就是非document的node,例如文件夹 | `NodeCreateRequest` | `NodeResponse` |
| `DELETE` | `/works/{works_id}/node/{node_id}` | 删除节点 |  |  |
| `PATCH` | `/works/{works_id}/node/{node_id}` | 更新节点 | `NodeUpdateRequest` |  |
| `GET` | `/works/{works_id}/documents` | 获取依赖关系 |  | `RelationshipResposne` |
| `PATCH` | `/works/{works_id}/node/{node_id}/to/{node_id}` | 迁移节点(改变节点之间的关系) |  |  |

#### 模型明细
```python
# controller数据模型
class DocumentCreateRequest(BaseModel): # 固定类型为document
    title: str
    description: str | None = None
    fater_node_id: UUID|None = None

class DocumentResponse(BaseModel): # 固定类型为document
    document_id:UUID
    title: str
    description: str | None = None
    fater_node_id: UUID|None = None

class DocumentUploadRequest(BaseModel):
    title: str| None = None
    description: str | None = None
    fater_node_id: UUID|None = None
    full_text:str|None = None # 为None时不更新

class DocumentDetailResponse(BaseModel): # 固定类型为document
    title: str
    description: str | None = None
    fater_node_id: UUID|None = None
    full_text:str|None = None # 为None时不更新

class NodeCreateRequest(BaseModel):
    node_name: str
    description: str | None = None
    node_type: Literal[ "folder"]
    fater_node_id: UUID|None = None

class NodeResponse(BaseModel):
    node_id: str
    node_name: str
    description: str | None = None
    node_type: Literal["folder"]
    fater_node_id: UUID|None = None

class NodeUpdateRequest(BaseModel):
    node_name: str| None = None
    description: str | None = None
    node_type: Literal["folder"]
    fater_node_id: UUID|None = None

class RelationshipResposne(BaseModel):
    works_document: List[NodeDTO] = []
    works_documents_relationship: List[EdgeDTO] = []

```

<!--  以下就是插件的内容了 -->
### 知识库模块(插件): 60xxx
#### 接口列表
| Method | Path | Description | Payload/Params | Response |
| :--- | :--- | :--- | :--- | :--- |
| `GET` | `/plugs/kds` | 获取知识库列表 |  | `List[KDMetaResponse]` |
| `GET` | `/plugs/kds/{kd_id}` | 获取知识库详情(知识点) |  | `List[KDDescriptionResponse]` |
| `POST` | `/plugs/kds` | 知识库构建 | `KDCreateRequest` | `KDMetaResponse` |
| `POST` | `/plugs/kds/{kd_id}` | 知识库(知识点创建) | `KDDescriptionCreateRequest` | `KDDescriptionResponse` |
| `DELETE` | `/plugs/kds/{kd_id}` | 知识库删除 |  |  |
| `DELETE` | `/plugs/kds/{kd_id}/{kd_chunk_id}` | 知识库(知识点删除) |  |  |
| `PATCH` | `/plugs/kds/{kd_id}` | 知识库元数据修改 | `KDUpdataRequest` |  |
| `PATCH` | `/plugs/kds/{kd_id}/{kd_chunk_id}` | 知识库(知识点修改) | `KDDescriptionUpdataRequest` | |


#### 数据模型
```python
# config: 配置的数据结构
class KDConfig(BaseModel):
    plugin_id:UUID = 1
    name:str="知识库"
    enabled:bool=True
    config:dict = {
        from_data:system # 从数据库中获取数据, 暂时不可改
        data:{}# 就是下面的数据,
        data:{
            {
                "kd_id": 142,
                "kd_name": "知识库1",
                "kd_description": "这是一个知识库",
                "enable":true,
                "create_at": "2023-08-10T12:00:00Z",
                "chunks":{
                    "chunk_id": 1001,
                    "search_key": "关键词1",
                    "kd_context": "这是一个知识点",
                    "enable": true,
                    "create_at": "2023-08-10T12:00:00Z",
                    "update_at": "2023-08-10T12:00:00Z"
                }
            }
        }# 这个只是例子 
    } # 由于是系统的,所以数据就来自我们的数据库了。
    from_type:str = "system"
    scope_type:str = "work" # 工作空间的, 暂时不可改
    tags:List[str] = ["Agent","Human"] # 标签, 不可修改 

#  Controller
class KDMetaResponse(BaseModel):
    kd_id: UUID# 唯一标记
    enable:bool # 是否启用
    kd_name: str # 知识库名称
    kd_description: str | None = None # 知识库描述
    create_at:datetime # 创建时间

class KDDescriptionResponse(BaseModel):
    kd_chunk_id: UUID #唯一标志
    enable:bool # 是否启用
    search_key:str # 用于Agent搜索,类似标题
    kd_context: str|None = None # 相当于正文
    create_at:datetime # 创建时间
    update_at:datetime # 更新时间

class KDCreateRequest(BaseModel):
    kd_name: str # 知识库名称
    kd_description: str | None = None # 知识库描述

class KDDescriptionCreateRequest(BaseModel):
    kd_chunk_id: UUID #唯一标志
    search_key:str # 用于Agent搜索,类似标题
    kd_context: str|None = None # 相当于正文

class KDUpdataRequest(BaseModel):
    enable:bool # 是否启用
    kd_name: str # 知识库名称
    kd_description: str | None = None # 知识库描述

class KDDescriptionUpdataRequest(BaseModel):
    enable:bool # 是否启用
    search_key:str # 用于Agent搜索,类似标题
    kd_context: str|None = None # 相当于正文

```
### 记忆模块(插件): 61xxx
#### 接口列表
| Method | Path | Description | Payload/Params | Response |
| :--- | :--- | :--- | :--- | :--- |
| `GET` | `/plugs/memories` | 获取记忆列表 |  | `List[MemoryMetaResponse]` |
| `GET` | `/plugs/memories/{memory_id}` | 获取记忆详情 |  | `MemoryDetailResponse` |
| `POST` | `/plugs/memories` | 记忆创建 | `MemoryCreateRequest` | `MemoryMetaResponse` |
| `DELETE` | `/plugs/memories/{memory_id}` | 记忆删除 |  |  |
| `PATCH` | `/plugs/memories/{memory_id}` | 记忆修改 | `MemoryUpdataRequest` |  |

#### 数据模型
```python
# config: 配置的数据结构
class MemoryConfig(BaseModel):
    plugin_id:UUID = 2
    name:str="记忆"
    enabled:bool=True
    config:dict = {
        from_data:system # 从数据库中获取数据, 暂时不可改
        data:{}# 就是下面的数据,
        data:{
            {
                "memory_id": 142,
                "memory_name": "记忆1",
                "memory_type": "long\short", # 长记忆和短记忆
                "memory_description": "这是一个记忆",
                "enable":true,
                "create_at": "2023-08-10T12:00:00Z",
                "memory_content": "这是一个记忆内容"
            }
        }# 这个只是例子 
    } # 由于是系统的,所以数据就来自我们的数据库了。
    from_type:str = "system"
    scope_type:str = "global" # 全局的, 暂时不可改
    tags:List[str] = ["Agent"] # 标签, 不可修改 

#  Controller
class MemoryMetaResponse(BaseModel):
    memory_id: UUID# 唯一标记
    enable:bool # 是否启用
    memory_name: str # 记忆名称
    memory_description: str | None = None # 记忆描述
    create_at:datetime # 创建时间

class MemoryDetailResponse(BaseModel):
    memory_id: UUID# 唯一标记
    enable:bool # 是否启用
    memory_name: str # 记忆名称
    memory_type: str # 记忆类型
    memory_description: str | None = None # 记忆描述
    create_at:datetime # 创建时间
    memory_content: str | None = None # 记忆内容

class MemoryCreateRequest(BaseModel):
    memory_name: str # 记忆名称
    memory_type: str # 记忆类型
    memory_description: str | None = None # 记忆描述
    memory_context: str|None = None # 相当于正文

class MemoryUpdataRequest(BaseModel):
    enable:bool # 是否启用
    memory_name: str # 记忆名称   
    memory_description: str | None = None # 记忆描述  
    memory_context: str|None = None # 相当于正文

```

### Agent管理模块(插件): 62xxx
| Method | Path | Description | Payload/Params | Response |
| :--- | :--- | :--- | :--- | :--- |
| `GET` | `/plugs/agents/manager` | 获取Agent列表 |  | `List[AgentMetaResponse]` |
| `GET` | `/plugs/agents/manager/{agent_id}` | 获取Agent详情 |  | `AgentDetailResponse` |
| `POST` | `/plugs/agents/manager/{agent_id}/history/{session_id}` | Agent创建 |  | `AgentMessagesResponse` |
| `POST` | `/plugs/agents/manager/{agent_id}/history/{session_id}/messages` | Agent发送消息 | `MessagesSendRequest` | `SSE` |
| `PATCH` | `/plugs/agents/manager/{agent_id}` | Agent修改 | `AgentUpdataRequest` |  |

#### 数据模型
```python
# config: 配置的数据结构
class AgentManagerConfig(BaseModel):
    plugin_id:UUID = 3
    name:str="Agent管理"
    enabled:bool=True
    config:dict = {
        from_data:system # 从数据库中获取数据, 暂时不可改
        data:{}# 就是下面的数据,
        data:{
            {
                "agents":
                    [
                        "agent_id": 142,
                        "agent_name": "Agent1",
                        "agent_description": "这是一个Agent",
                        "agent_type": "context\\no_context", # 有无上下文的,决定下面history有没有对话记录
                        "enable":true,
                        "broadcast":true,
                        "history":{
                            [
                                {
                                    "123-456-789":
                                    [
                                        {"role":"user","content":"你好"},
                                        {"role":"assistant","content":"你好！有什么我可以帮助你的吗？"}
                                    ]
                                }   
                            ]
                        } 
                        "create_at": "2023-08-10T12:00:00Z",
                ]
            }
        }# 这个只是例子 
    } # 由于是系统的,所以数据就来自我们的数据库了。
    from_type:str = "system"
    scope_type:str = "global" # 全局的, 暂时不可改
    tags:List[str] = ["Agent"] # 标签, 不可修改 

#  Controller
class AgentMetaResponse(BaseModel):
    agent_id: UUID# 唯一标记
    enable:bool # 是否启用
    agent_name: str # Agent名称
    broadcast:bool # 是否广播
    agent_description: str | None = None # Agent描述
    create_at:datetime # 创建时间

class AgentDetailResponse(BaseModel):
    agent_id: UUID# 唯一标记
    enable:bool # 是否启用
    agent_name: str # Agent名称
    broadcast:bool # 是否广播
    agent_type: str # Agent类型
    agent_description: str | None = None # Agent描述
    create_at:datetime # 创建时间
    history_meta:dict = {} # 历史记录, 键是会话ID, 值是消息列表
    
class AgentMessagesResponse(BaseModel):
    session_id: str # 会话ID
    messages: List[dict] # 消息列表

class MessagesSendRequest(BaseModel):
    messages_type: str = text
    context: any

# 只是表述,不是把这个对象返还出去
class MessagesSSE(BaseModel):
    id:str # 事件ID,agent_name:session_id:+时间戳
    data:any # 由于Agent自己决定
    event:str # Agent自定义的type

class AgentUpdataRequest(BaseModel):
    broadcast:bool # 是否广播

```

### 作品类型管理模块(插件): 63xxx
| Method | Path | Description | Payload/Params | Response |
| :--- | :--- | :--- | :--- | :--- |
| `GET` | `/plugs/work/type` | 获取作品类型列表 |  | `List[WorkTypeMetaResponse]` |
| `GET` | `/plugs/work/type/{work_type_id}` | 获取作品类型详情 |  | `WorkTypeDetailResponse` |
#### 数据模型
```python
# config: 配置的数据结构
class WorkType(BaseModel):
    plugin_id:UUID = 4
    name:str="作品类型"
    enabled:bool=True
    config:dict = {
        from_data:system # 从数据库中获取数据, 暂时不可改
        data:{}# 就是下面的数据,
        data:{
            {
                "work_type_id": 1,
                "work_type": "小说",
                "node_tags":["document","folder"],
                "relationship": [ # 这里表述的可以的嵌套逻辑是 folder下可以有document,但是folder下没有folder,document下面也没有东西了。
                    {"folder":"document"},
                ]
            }
        }# 这个只是例子 
    } # 由于是系统的,所以数据就来自我们的数据库了。
    from_type:str = "system"
    scope_type:str = "global" # 全局的, 暂时不可改
    tags:List[str] = ["System"] # 标签, 不可修改 

#  Controller
class WorkTypeResponse(BaseModel):
    work_type_id: UUID# 唯一标记
    enable:bool # 是否启用
    work_type: str # 作品类型

class WorkTypeDetailResponse(BaseModel):
    work_type_id: UUID# 唯一标记
    enable:bool # 是否启用
    node_tags:list
    relationship:list 


```


### 文档创作Chat助手(插件): 64xxx
| Method | Path | Description | Payload/Params | Response |
| :--- | :--- | :--- | :--- | :--- |
| `GET` | `/plugs/agent/document_helper/config` | 获取文档创作Chat助手的配置 |  | `DocumentHelperChatConfigResponse` |
| `POST` | `/plugs/agent/document_helper/config` | 修改文档创作Chat助手的配置 | `MemoryUpdataRequest` |  |
| `POST` | `/plugs/agent/document_helper/chat/{session_id}` | 和文档创作助手聊天 | `MessagesSendRequest` | `SSE` |

#### 数据模型
```python
# config: 配置的数据结构
class DocumentHelperChatConfig(BaseModel):
    plugin_id:UUID = 5
    name:str="文档创作助手"
    enabled:bool=True
    config:dict = {
        from_data:system # 从数据库中获取数据, 暂时不可改
        data:{}# 就是下面的数据,
        data:{
            {
                "model_name":"qwen",
                "base_url":"https...",
                "api_key":"sk-xxxx",
                "user_prompt":"..." 
            }
        }# 这个只是例子 
    } # 由于是系统的,所以数据就来自我们的数据库了。
    from_type:str = "system"
    scope_type:str = "document" # 全局的, 暂时不可改
    tags:List[str] = ["Agent","Chat"] # 标签, 不可修改 

#  Controller
class DocumentHelperChatConfigResponse(BaseModel):
    model_name: str # 模型名称
    base_url: str # 基础URL
    api_key: str # API密钥
    user_prompt: str # 用户提示

class DocumentHelperChatConfigRequest(BaseModel):
    model_name: str # 模型名称
    base_url: str # 基础URL
    api_key: str # API密钥
    user_prompt: str # 用户提示

SSE约定
    "id":"document_helper:session_id:timestamp"
    "event":"tool_call/tool_reps/chat/end"
    "data":{
        message_chunk:str|dict # 消息内容, 字符串或者字典dict一般是tool相关的
    }
    "retry": 30000 # 重试时间, 单位毫秒


```





### 项目chat助手(插件): 65xxx
| Method | Path | Description | Payload/Params | Response |
| :--- | :--- | :--- | :--- | :--- |
| `GET` | `/plugs/agent/project_helper/config` | 获取项目chat助手的配置 |  | `ProjectHelperChatConfigResponse` |
| `GET` | `/plugs/agent/project_helper/resources` | 获取项目chat助手的资源 |  | `List[ProjectHelperResourcesResponse]` |
| `POST` | `/plugs/agent/project_helper/resources` | 修改项目chat助手的资源 | `ProjectHelperResourcesRequest` |  |
| `POST` | `/plugs/agent/project_helper/config` | 修改项目chat助手的配置 | `MemoryUpdataRequest` |  |
| `POST` | `/plugs/agent/project_helper/chat/{session_id}` | 和项目chat助手聊天 | `MessagesSendRequest` | `SSE` |

#### 数据模型
```python
# config: 配置的数据结构
class ProjectHelperChatConfig(BaseModel):
    plugin_id:UUID = 6
    name:str="项目chat助手"
    enabled:bool=True
    config:dict = {
        from_data:system # 从数据库中获取数据, 暂时不可改
        data:{}# 就是下面的数据,
        data:{
            {
                "model_name":"qwen",
                "base_url":"https...",
                "api_key":"sk-xxxx",
                "user_prompt":"...",
                "resources":[
                    {
                        "home":True,
                        "document":False
                    }
                ] # 这里开启的页面,在resources下的页面用户可以和ProjectHelper进行对话,并获取该页面相关的信息。
            }
        }# 这个只是例子 
    } # 由于是系统的,所以数据就来自我们的数据库了。
    from_type:str = "system"
    scope_type:str = "global" # 全局的, 暂时不可改
    tags:List[str] = ["Agent","Chat"] # 标签, 不可修改 

#  Controller
class ProjectHelperChatConfigResponse(BaseModel):
    model_name: str # 模型名称
    base_url: str # 基础URL
    api_key: str # API密钥
    user_prompt: str # 用户提示

class ProjectHelperChatConfigRequest(BaseModel):
    model_name: str # 模型名称
    base_url: str # 基础URL
    api_key: str # API密钥
    user_prompt: str # 用户提示

class ProjectHelperResourcesResponse(BaseModel):
    resource_name:str
    enable:bool
class ProjectHelperResourcesRequest(BaseModel):
    resource_name:str
    enable:bool
    
SSE约定
    "id":"document_helper:session_id:timestamp"
    "event":"chat/end"
    "data":{
        message_chunk:str
    }
    "retry": 30000 # 重试时间, 单位毫秒



```

## 7. 统一数据库设计 (Database Schema)

> **说明**: 
> 1. 本项目使用 `SQLModel` (基于 SQLAlchemy + Pydantic) 定义数据库模型。
> 2. Agent 的运行状态（State/History）由 **LangGraph Checkpointer** 自动托管（通常涉及 `checkpoints`, `checkpoint_writes` 等表），**无需**在此处手动定义。
> 3. 这里的模型主要关注：业务实体、插件配置、资源关系以及“信箱”通知系统。

### 7.1 核心基础 (Core & Plugin)

```python
from sqlmodel import SQLModel, Field, Relationship
from sqlalchemy import Column, JSON, TIMESTAMP
from typing import List, Optional, Dict
from datetime import datetime
import uuid

def create_uuid() -> str:
    return str(uuid.uuid4())

def get_now_time() -> datetime:
    return datetime.now()

class PluginSQLEntity(SQLModel, table=True):
    """
    插件注册表: 定义系统中所有可用的插件（能力）。
    """
    __tablename__ = "plugin"

    id: str = Field(default_factory=create_uuid, primary_key=True, description="插件ID")
    name: str = Field(index=True, unique=True, description="插件名称")
    description: Optional[str] = Field(default=None, description="插件描述")
    
    # 插件类型与作用域
    from_type: str = Field(default="system", description="来源: system(系统内置), custom(用户自定义)")
    scope_type: str = Field(default="work", description="作用域: global(全局), work(作品级), document(文档级)")
    
    # 全局开关
    enabled: bool = Field(default=True, description="全局启用状态")
    
    # 配置定义 (Schema) 与 默认配置
    # 存储 JSON 数据，例如 {"api_key": "string", "broadcast": "boolean"}
    config_schema: Dict = Field(default={}, sa_column=Column(JSON), description="配置Schema定义")
    default_config: Dict = Field(default={}, sa_column=Column(JSON), description="默认配置值")
    
    tags: List[str] = Field(default=[], sa_column=Column(JSON), description="标签列表")

    # Relationships
    work_mappings: List["WorkPluginMappingSQLEntity"] = Relationship(back_populates="plugin")


class WorkSQLEntity(SQLModel, table=True):
    """
    作品表: 项目的核心实体（如一本小说）。
    """
    __tablename__ = "work"

    id: str = Field(default_factory=create_uuid, primary_key=True, description="作品ID")
    
    name: str = Field(default="未命名作品", description="作品名称")
    cover_image_url: Optional[str] = Field(default=None, description="封面图片URL")
    summary: Optional[str] = Field(default=None, description="作品简介")
    
    # 作品类型，对应某种 WorkType 插件的标识
    work_type: str = Field(default="novel", description="作品类型标识")
    
    state: str = Field(default="updating", description="状态: updating, completed")
    
    create_time: datetime = Field(default_factory=get_now_time, sa_type=TIMESTAMP(timezone=True))
    update_time: datetime = Field(default_factory=get_now_time, sa_type=TIMESTAMP(timezone=True))

    # Relationships
    plugin_mappings: List["WorkPluginMappingSQLEntity"] = Relationship(back_populates="work")
    # nodes: List["NodeSQLEntity"] = Relationship(back_populates="work")


class WorkPluginMappingSQLEntity(SQLModel, table=True):
    """
    作品-插件关联表: 记录某个作品启用了哪些插件，以及特定的配置。
    例如：某本小说开启了“历史考据助手”插件，并配置了特定的 Prompt。
    """
    __tablename__ = "work_plugin_mapping"

    id: str = Field(default_factory=create_uuid, primary_key=True)
    
    work_id: str = Field(foreign_key="work.id", index=True)
    plugin_id: str = Field(foreign_key="plugin.id", index=True)
    
    # 该作品下是否启用
    enabled: bool = Field(default=True)
    
    # 实例配置: 覆盖 Plugin 的 default_config
    # 关键点: Agent 的 "broadcast" (信箱通知) 开关通常在此配置
    # e.g., {"broadcast": true, "model": "gpt-4"}
    config: Dict = Field(default={}, sa_column=Column(JSON), description="作品级配置覆盖")
    
    # Relationships
    work: WorkSQLEntity = Relationship(back_populates="plugin_mappings")
    plugin: PluginSQLEntity = Relationship(back_populates="work_mappings")

```

### 7.2 Agent管理

```python
class AgentsManagerSQLEntity(SQLModel, table=True):
    """
    agent的管理模块
    """
    __tablename__ = "agents_manager"

    id:str = Field(default_factory=create_uuid, primary_key=True, description="agent的id")
    name:str = Field(description="agent的名称")
    description:str = Field(description="agent的描述")
    agent_type:str
    enabled:bool
    broadcast:bool
    histories:List[str]
    config:Dict = Field(default={}, sa_column=Column(JSON), description="agent的配置")
    create_time:datetime = Field(default_factory=get_now_time, sa_type=TIMESTAMP(timezone=True))



```

### 7.3 内容与结构 (Content & Graph)

```python
class NodeSQLEntity(SQLModel, table=True):
    """
    节点表: 构成作品内容的原子单位（文档、文件夹、白板等）。
    """
    __tablename__ = "node"

    id: str = Field(default_factory=create_uuid, primary_key=True, description="节点ID")
    work_id: str = Field(foreign_key="work.id", index=True)
    
    name: str = Field(default="未命名节点")
    node_type: str = Field(description="类型: document, folder, whiteboard...")
    
    create_time: datetime = Field(default_factory=get_now_time, sa_type=TIMESTAMP(timezone=True))
    update_time: datetime = Field(default_factory=get_now_time, sa_type=TIMESTAMP(timezone=True))

class NodeRelationshipSQLEntity(SQLModel, table=True):
    """
    节点关系表: 定义节点之间的非层级关系（如引用、链接）。
    支持网状叙事结构。
    """
    __tablename__ = "node_relationship"

    id: str = Field(default_factory=create_uuid, primary_key=True)
    work_id: str = Field(foreign_key="work.id", index=True)
    
    from_node_id: str = Field(foreign_key="node.id", index=True)
    to_node_id: str = Field(foreign_key="node.id", index=True)

class DocumentVersionSQLEntity(SQLModel, table=True):
    """
    文档版本表: 存储 Node (类型为 document) 的实际内容历史。
    """
    __tablename__ = "document_version"

    id: str = Field(default_factory=create_uuid, primary_key=True)
    node_id: str = Field(foreign_key="node.id", index=True)
    
    content: str = Field(default="", description="文档内容 (HTML/JSON/Markdown)")
    word_count: int = Field(default=0)
    
    create_time: datetime = Field(default_factory=get_now_time, sa_type=TIMESTAMP(timezone=True))



```

### 7.4 知识库(Knowledge)(插件)

```python
class KnowledgeBaseSQLEntity(SQLModel, table=True):
    """
    知识库元数据表
    """
    __tablename__ = "knowledge_base"
    
    id: str = Field(default_factory=create_uuid, primary_key=True)
    work_id: Optional[str] = Field(default=None, index=True, description="关联作品ID，空则为全局")
    name: str
    description: Optional[str] = None
    
    create_time: datetime = Field(default_factory=get_now_time, sa_type=TIMESTAMP(timezone=True))

class KnowledgeChunkSQLEntity(SQLModel, table=True):
    __tablename__ = "knowledge_chunk"
    
    id: str = Field(default_factory=create_uuid, primary_key=True)
    kb_id: str = Field(foreign_key="knowledge_base.id", index=True)
    
    content: str = Field(description="文本内容")


```

### 7.5 记忆库(Memory)(插件)

```python
class MemorySQLEntity(SQLModel, table=True):
    """
    知识库元数据表
    """
    __tablename__ = "knowledge_base"
    
    id: str = Field(default_factory=create_uuid, primary_key=True)
    work_id: Optional[str] = Field(default=None, index=True, description="关联作品ID，空则为全局")
    name: str
    description: Optional[str] = None
    memory_type:str
    context:str
    create_time: datetime = Field(default_factory=get_now_time, sa_type=TIMESTAMP(timezone=True))



