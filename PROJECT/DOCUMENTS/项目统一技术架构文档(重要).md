# 项目统一技术架构文档 (Unified Technical Architecture)

> **版本**: v1.1
> **日期**: 2026-01-21
> **提交方**: masterAgent
> **状态**: 更新 (Updated)
> **说明**: 本文档作为项目开发的唯一技术事实来源 (Single Source of Truth)，统一插件化、Agent 编排与前后端接口约定。

---

## 1. 系统架构概览

采用 **前后端分离** + **插件化能力** + **Agent 编排** 的架构。

- **前端**: Next.js 14 (App Router) + Zustand + TailwindCSS + Radix UI + Tiptap
- **后端**: FastAPI + SQLModel + PostgreSQL (pgvector)
- **Agent**: LangGraph + LangChain 1.1+（create_agent 与中间件）
- **插件运行时**: 能力注册表 + UI 插槽 + 命令系统

### 架构原则
1. 核心最小化，插件优先扩展
2. 事件/命令驱动，插件之间不直接耦合
3. 可中断与可恢复，支持人工介入
4. 可观测与可审计，统一日志与追踪
5. 版本兼容与能力声明，保持可持续演进

---

## 2. 前端技术选型与需求
### 技术选型
| 模块 | 选型 | 理由 |
| :--- | :--- | :--- |
| **框架** | **Next.js 14+ (App Router)** | SSR/SSG 支持完善，路由一致性强。 |
| **语言** | **TypeScript 5.x** | 类型安全与可维护性提升。 |
| **样式** | **TailwindCSS** | 原子化样式体系，迭代速度快。 |
| **组件库** | **Radix UI + 自建组件（Shadcn 风格）** | Headless UI 便于复杂交互组合。 |
| **图标** | **Lucide React** | 轻量统一。 |
| **图表** | **Reagraph** | 知识图谱可视化需求。 |
| **状态管理** | **Zustand** | 轻量高性能。 |
| **AI 交互** | **fetch + eventsource-parser（SSE）** | 兼容流式输出与中断。 |
| **Tiptap 渲染** | **tiptap** | 富文本编辑能力稳定。 |
| **消息提示** | **Sonner** | 轻量统一提示。 |
| **请求发送** | **Axios（封装 request.ts）** | 统一鉴权与错误处理。 |
| **SSE增强** | **@microsoft/fetch-event-source** | 支持自定义 Header 与 POST 流式。 |

### 前端关键能力
- 插件 UI 插槽与面板布局
- 命令系统与快捷键
- 文档 patch 应用与冲突提示
- SSE 流式渲染与中断处理
- 插件启停与权限提示

---

## 3. 后端技术选型与需求
### 技术选型
| 模块 | 选型 | 理由 |
| :--- | :--- | :--- |
| **框架** | **FastAPI** | 异步友好，接口规范清晰。 |
| **ORM** | **SQLModel** | 类型安全与模型一致性。 |
| **数据库** | **PostgreSQL + pgvector** | 结构化数据与向量检索兼容。 |

### 后端关键能力
- 插件注册、启停与权限控制
- 作品/文档/关系数据管理
- 保存与 checkpoint 机制
- AI 调用网关与配额审计
- Agent 会话与线程管理

---

## 4. Agent 技术选型与需求
### 技术选型
| 模块 | 选型 | 理由 |
| :--- | :--- | :--- |
| **编排框架** | **LangGraph** | 状态图编排与持久化执行。 |
| **模型适配** | **LangChain 1.1+** | 多模型与工具调用统一接口。 |

### Agent 关键能力
- StateGraph 与子图复用
- Command 更新状态并动态路由
- interrupt 人工介入与审批
- checkpointer + thread_id 可恢复会话
- astream/astream_events 流式观测

---

## 插件概念
插件有2种特殊的标签,一个叫来源,分别表示系统的,和自定义的,另外一个叫作用域,一共有3种,全局,作品级,文档级。在我们设计里,将插件分为了插件的结构定义(存储在插件管理中)另外一个是插件数值定义,存储在各自的插件系统中,可能来自数据库,也可能纯粹的json或者其他的东西。只要符合插件的结构定义即可。插件的结构中包含,插件数据结构,默认值和开启状态。之间的关系是 "结构"的开启关闭优先级 > 实际中的开启和关闭(不过一般都是作品级别的了,一般要在数据结构内部+一个是否开启的字段),例如,在结构中开启,那么在项目的其他地方就可以选择性的开启(如果是全局的,结构开启就是全部开启,没有选择性),而如果结构关闭了,在任何地方都不可以开启。
"数值"的数据优先级大于"结构"的优先级,也就是实际的会覆盖默认的,如果实际没有配置,就会采用默认的。 

## 5. 前后端接口规范
通用前缀: `/api/v1`，以下路径皆省略前缀。

- 统一响应包装: `{code:int,data:T,message:str}`，SSE 流式除外
- 成功时: `code = 200`
- 非业务错误: `code = 50000`
- 业务错误码: `5 位数`
- HTTP status 按标准语义返回，`code` 作为业务分支
- 统一时间格式: ISO-8601
- 对外接口只出现 `*Request/*Response`，内部模型禁止直接作为 Response 字段

---

## 6. 业务模块接口清单
### 插件管理模块 (Plugin): 500xx
#### 接口列表
| Method | Path | Description | Payload/Params | Response |
| :--- | :--- | :--- | :--- | :--- |
| `GET` | `/plugin` | 获取插件列表 |  | `List[PluginMetaResponse]` |
| `GET` | `/plugin/{plugin_id}` | 获取插件详情 |  | `PluginResponse` |
| `PATCH` | `/plugin/{plugin_id}` | 启用或更新配置 | `PluginUpdateRequest` |  |

#### 模型明细
```python

class PluginMetaResponse(BaseModel):
    id:UUID
    name: str
    enabled:bool

class PluginResponse(BaseModel):
    id:UUID
    name: str
    description:str
    enabled:bool
    config:dict
    from_type:PluginFromTypeEnum #插件来源类型,系统级别不可删除,自定义插件可删除
    scope_type:PluginScopeTypeEnum #插件作用域类型,global全局生效,work和document可以在作品中选择性开启或关闭。
    tags:List[str] #插件标签,用于搜索的

class PluginUpdateRequest(BaseModel):
    enabled:bool|None= None
    config:dict|None = None


# class PluginWorkMapping(BaseModel):
#     # 用于对work进行更加细致的配置
#     id:UUID # 唯一id
#     plugin_id:UUID # 配置id,对应上面的id
#     work_id:UUID # 作品id
#     enabled: bool #插件是否启用,在work中启用后,才会在work中生效。除非其作用等级是global。
#     config:dict #插件配置参数:key为变量名,value为变量名值例如:{"api_key":"sk-...."},优先级高于默认的。 

```

### 作品管理模块: 510xx
#### 接口列表
| Method | Path | Description | Payload/Params | Response |
| :--- | :--- | :--- | :--- | :--- |
| `POST` | `/work` | 创建作品 | `CreateWorkRequest` | `WorkMetaResponse` |
| `GET` | `/work` | 获取作品列表 |  | `List[WorkMetaResponse]` |
| `PATCH` | `/work/{work_id}` | 更新作品元信息 | `WorkMetaUpdateRequest` |  |
| `DELETE` | `/work/{work_id}` | 删除作品 |  ||
| `GET` | `/work/{work_id}` | 获取作品详情 |  | `WorkDetailResponse` |
| `GET` | `/work/{work_id}/plugin` | 获取作品插件列表 |  | `List[WorkPluginMetaResponse]` |
| `PATCH` | `/work/{work_id}/plugin/{plugin_id}/enabled?enabled={enabled}` | 更新作品插件启动状态  |  |  |
| `GET` | `/work/{work_id}/plugin/{plugin_id}` | 获取作品插件详情 |  | `WorkPluginDetailResponse` |
| `PATCH` | `/work/{work_id}/plugin/{plugin_id}` | 更新作品插件配置 | `UpdateWorkPluginRequest` | |


#### 模型明细
```python
# 在servcie中的DTO(可复用)
class WorkMetaDTO(BaseModel):
    id: UUID
    cover_image_url: str | None = None
    name: str | None = None
    summary: str | None = None
    state: WorkEnum
    type: WorkTypeEnum
    create_at: datetime
    update_at: datetime


# 文档关系
class NodeDTO(BaseModel):
    id: UUID
    name: str
    description: str | None = None
    type: NodeTypeEnum

class EdgeDTO(BaseModel):
    from_node_id: UUID
    to_node_ids:List[UUID]

# controller层的数据模型
class CreateWorkRequest(BaseModel):
    cover_image_url: str | None = None # 前端是怎么加载图片的?
    name: str | None = None
    summary: str | None = None
    type: WorkTypeEnum  # 本质上是插件名->给定了作品内文档的组织形式。| 目前我们只支持小说模式
    enabled_plugin_id_list: List[UUID] = [] # 用户可配置的插件

class WorkMetaResponse(BaseModel):
    meta: WorkMetaDTO

class WorkMetaUpdateRequest(BaseModel):
    cover_image_url: str | None = None
    name: str | None = None
    summary: str | None = None
    state: WorkEnum

class WorkDetailResponse(BaseModel):
    meta: WorkMetaDTO
    document: List[NodeDTO] = []
    relationship: List[EdgeDTO] = []

class WorkPluginMetaResponse(BaseModel):
    id: UUID # 插件id
    name: str
    enabled:bool
    description: str

class WorkPluginDetailResponse(BaseModel):
    id:UUID # 插件id
    name: str #插件名
    description: str #插件描述
    enabled: bool 
    config:dict 
    from_type:PluginFromTypeEnum #插件来源类型,系统级别不可删除,自定义插件可删除
    scope_type:PluginScopeTypeEnum #插件作用域类型,global全局生效,work和document可以在作品中选择
    tags:List[str] #插件标签,用于搜索的

class UpdateWorkPluginRequest(BaseModel):
    enabled: bool 
    config:dict 


```

### 文档管理模块: 511xx
#### 接口列表
| Method | Path | Description | Payload/Params | Response |
| :--- | :--- | :--- | :--- | :--- |
| `POST` | `/work/{work_id}/document` | 创建文档 | `DocumentCreateRequest` | `DocumentResponse` |
| `DELETE` | `/work/{work_id}/document/{document_id}` | 删除文档 |  |  |
| `PATCH` | `/work/{work_id}/document/{document_id}` | 更新文档 | `DocumentUploadRequest` |  |
| `GET` | `/work/{work_id}/document/{document_id}` | 获取文档详情 |  | `DocumentDetailResponse` |
| `POST` | `/work/{work_id}/node` | 创建节点,也就是非document的node,例如文件夹 | `NodeCreateRequest` | `NodeResponse` |
| `DELETE` | `/work/{work_id}/node/{node_id}` | 删除节点 |  |  |
| `PATCH` | `/work/{work_id}/node/{node_id}` | 更新节点 | `NodeUpdateRequest` |  |
| `GET` | `/work/{work_id}/document` | 获取依赖关系 |  | `RelationshipResponse` |
| `PATCH` | `/work/{work_id}/node/{node_id}/parent/{parent_node_id}` | 迁移节点(改变节点之间的关系) |  |  |

#### 模型明细
```python
# controller数据模型
class DocumentCreateRequest(BaseModel): # 固定类型为document
    title: str
    description: str | None = None
    from_node_id: UUID|None = None

class DocumentResponse(BaseModel): # 固定类型为document
    id:UUID # 文档id
    title: str
    description: str | None = None
    from_node_id: UUID|None = None      

class DocumentUploadRequest(BaseModel):
    title: str| None = None
    description: str | None = None
    from_node_id: UUID|None = None
    full_text:str|None = None # 为None时不更新

class DocumentDetailResponse(BaseModel): # 固定类型为document
    title: str
    description: str | None = None
    from_node_id: UUID|None = None
    full_text:str|None = None # 为None时不更新

class NodeCreateRequest(BaseModel):
    name: str
    description: str | None = None
    type: NodeTypeEnum
    from_node_id: UUID|None = None

class NodeResponse(BaseModel):
    id: UUID
    name: str
    description: str | None = None
    type: NodeTypeEnum
    from_node_id: UUID|None = None

class NodeUpdateRequest(BaseModel):
    name: str| None = None
    description: str | None = None
    from_node_id: UUID|None = None

class RelationshipResponse(BaseModel):
    document: List[NodeDTO] = []
    relationship: List[EdgeDTO] = []

```

<!--  以下就是插件的内容了 -->
### 知识库模块(插件): 60xxx
#### 接口列表
| Method | Path | Description | Payload/Params | Response |
| :--- | :--- | :--- | :--- | :--- |
| `GET` | `/plugin/kd` | 获取知识库列表 |  | `List[KDMetaResponse]` |
| `GET` | `/plugin/kd/{id}` | 获取知识库详情(知识点) |  | `List[KDDescriptionResponse]` |
| `POST` | `/plugin/kd` | 知识库构建 | `KDCreateRequest` | `KDMetaResponse` |
| `POST` | `/plugin/kd/{id}` | 知识库(知识点创建) | `KDDescriptionCreateRequest` | `KDDescriptionResponse` |
| `DELETE` | `/plugin/kd/{id}` | 知识库删除 |  |  |
| `DELETE` | `/plugin/kd/{id}/{chunk_id}` | 知识库(知识点删除) |  |  |
| `PATCH` | `/plugin/kd/{id}` | 知识库元数据修改 | `KDUpdateRequest` |  |
| `PATCH` | `/plugin/kd/{id}/{chunk_id}` | 知识库(知识点修改) | `KDDescriptionUpdateRequest` | |


#### 数据模型
```python

#  Controller
class KDMetaResponse(BaseModel):
    id: UUID# 唯一标记
    enabled:bool # 是否启用
    titel: str # 知识库名称
    description: str | None = None # 知识库描述
    create_at:datetime # 创建时间

class KDDescriptionResponse(BaseModel):
    chunk_id: UUID #唯一标志
    enabled:bool # 是否启用
    search_keys:list[str] # 用于Agent搜索,类似标题
    context: str|None = None # 相当于正文
    create_at:datetime # 创建时间
    update_at:datetime # 更新时间

class KDCreateRequest(BaseModel):
    name: str # 知识库名称
    description: str | None = None # 知识库描述

class KDDescriptionCreateRequest(BaseModel):
    chunk_id: UUID #唯一标志
    search_keys:list[str] # 用于Agent搜索,类似标题
    context: str|None = None # 相当于正文

class KDUpdateRequest(BaseModel):
    enabled:bool # 是否启用
    name: str # 知识库名称
    description: str | None = None # 知识库描述

class KDDescriptionUpdateRequest(BaseModel):
    enabled:bool # 是否启用
    search_keys:List[str] # 用于Agent搜索,类似标题
    context: str|None = None # 相当于正文

```
### 记忆模块(插件): 61xxx
#### 接口列表
| Method | Path | Description | Payload/Params | Response |
| :--- | :--- | :--- | :--- | :--- |
| `GET` | `/plugin/memory` | 获取记忆列表 |  | `List[MemoryMetaResponse]` |
| `GET` | `/plugin/memory/{memory_id}` | 获取记忆详情 |  | `MemoryDetailResponse` |
| `POST` | `/plugin/memory` | 记忆创建 | `MemoryCreateRequest` | `MemoryMetaResponse` |
| `DELETE` | `/plugin/memory/{memory_id}` | 记忆删除 |  |  |
| `PATCH` | `/plugin/memory/{memory_id}` | 记忆修改 | `MemoryUpdateRequest` |  |

#### 数据模型
```python

#  Controller
class MemoryMetaResponse(BaseModel):
    id: UUID# 唯一标记
    enabled:bool # 是否启用
    name: str # 记忆名称
    description: str | None = None # 记忆描述
    create_at:datetime # 创建时间

class MemoryDetailResponse(BaseModel):
    id: UUID# 唯一标记
    enabled:bool # 是否启用
    name: str # 记忆名称
    type: MemoryTypeEnum # 记忆类型
    description: str | None = None # 记忆描述
    create_at:datetime # 创建时间
    context: str | None = None # 记忆内容

class MemoryCreateRequest(BaseModel):
    name: str # 记忆名称
    type: MemoryTypeEnum # 记忆类型
    description: str | None = None # 记忆描述
    context: str|None = None # 相当于正文

class MemoryUpdateRequest(BaseModel):
    enabled:bool # 是否启用
    name: str # 记忆名称   
    description: str | None = None # 记忆描述  
    context: str|None = None # 相当于正文

```

### Agent管理模块(插件): 62xxx
| Method | Path | Description | Payload/Params | Response |
| :--- | :--- | :--- | :--- | :--- |
| `GET` | `/plugin/agent/manager` | 获取Agent列表 |  | `List[AgentMetaResponse]` |
| `GET` | `/plugin/agent/manager/{agent_id}` | 获取Agent详情 |  | `AgentDetailResponse` |
| `POST` | `/plugin/agent/manager/{agent_id}/history/{session_id}` | 会话创建 |  | `AgentMessagesResponse` |
| `POST` | `/plugin/agent/manager/{agent_id}/history/{session_id}/messages` | Agent发送消息 | `MessagesSendRequest` | `SSE` |
| `PATCH` | `/plugin/agent/manager/{agent_id}` | Agent修改 | `AgentUpdateRequest` |  |

#### 数据模型
```python


#  Controller
class AgentMetaResponse(BaseModel):
    id: UUID# 唯一标记
    enabled:bool # 是否启用
    name: str # Agent名称
    broadcast:bool # 是否广播
    description: str | None = None # Agent描述
    create_at:datetime # 创建时间

class AgentDetailResponse(BaseModel):
    id: UUID# 唯一标记
    enabled:bool # 是否启用
    name: str # Agent名称
    broadcast:bool # 是否广播
    context_size : int, # 表示上下文的大小,单位token,若写入 -1 表示不做任何限制,因此也不会进行总结。0表示这个Agent没有历史记录的概念
    is_summary: bool, # 表示是否对上下文进行总结,在超出了上面的上下文大小之后
    description: str | None = None # Agent描述
    create_at:datetime # 创建时间
    sessions:list[str] # 就是会话id列表
    
class AgentMessagesResponse(BaseModel):
    session_id: UUID # 会话ID
    messages: List[dict] # 消息列表

class MessagesSendRequest(BaseModel):
    context: str # 上下文

# 只是表述,不是把这个对象返还出去
class MessagesSSE(BaseModel):
    id:UUID # 事件ID,agent_name:session_id:+时间戳
    data:any # 由于Agent自己决定
    event:str # Agent自定义的type

class AgentUpdateRequest(BaseModel):
    broadcast:bool # 是否广播

```

### 作品类型管理模块(插件): 63xxx
| Method | Path | Description | Payload/Params | Response |
| :--- | :--- | :--- | :--- | :--- |
| `GET` | `/plugin/work/type` | 获取作品类型列表 |  | `List[WorkTypeMetaResponse]` |
| `GET` | `/plugin/work/type/{work_type_id}` | 获取作品类型详情 |  | `WorkTypeDetailResponse` |
#### 数据模型
```python

#  Controller
class WorkTypeResponse(BaseModel):
    id: UUID# 唯一标记
    enabled:bool # 是否启用
    type: WorkTypeEnum # 作品类型

class WorkTypeDetailResponse(BaseModel):
    id: UUID# 唯一标记
    enabled:bool # 是否启用
    tags:list #节点标签
    relationship:list 
    configurable:bool  # 是否可配置


```


### 文档创作Chat助手(插件): 64xxx
| Method | Path | Description | Payload/Params | Response |
| :--- | :--- | :--- | :--- | :--- |
| `GET` | `/plugin/agent/document_helper/config` | 获取文档创作Chat助手的配置 |  | `DocumentHelperChatConfigResponse` |
| `POST` | `/plugin/agent/document_helper/config` | 修改文档创作Chat助手的配置 | `DocumentHelperChatConfigRequest` |  |
| `POST` | `/plugin/agent/document_helper/chat/{session_id}` | 和文档创作助手聊天 | `MessagesSendRequest` | `SSE` |

#### 数据模型
```python

#  Controller
class DocumentHelperChatConfigResponse(BaseModel):
    model_name: str # 模型名称
    base_url: str # 基础URL
    api_key: str # API密钥
    user_prompt: str # 用户提示

class DocumentHelperChatConfigRequest(BaseModel):
    model_name: str # 模型名称
    base_url: str # 基础URL
    api_key: str # API密钥
    user_prompt: str # 用户提示

SSE约定
    "id":"document_helper:session_id:timestamp"
    "event":"tool/chat/end"
    "data":{
        message_chunk:str|dict # 消息内容, 字符串或者字典dict一般是tool相关的
    }
    "retry": 30000 # 重试时间, 单位毫秒


```





### 项目chat助手(插件): 65xxx
| Method | Path | Description | Payload/Params | Response |
| :--- | :--- | :--- | :--- | :--- |
| `GET` | `/plugin/agent/project_helper/config` | 获取项目chat助手的配置 |  | `ProjectHelperChatConfigResponse` |
| `GET` | `/plugin/agent/project_helper/resources` | 获取项目chat助手的资源 |  | `List[ProjectHelperResourcesResponse]` |
| `POST` | `/plugin/agent/project_helper/resources` | 修改项目chat助手的资源 | `ProjectHelperResourcesRequest` |  |
| `POST` | `/plugin/agent/project_helper/config` | 修改项目chat助手的配置 | `ProjectHelperChatConfigRequest` |  |
| `POST` | `/plugin/agent/project_helper/chat/{session_id}` | 和项目chat助手聊天 | `MessagesSendRequest` | `SSE` |

#### 数据模型
```python


#  Controller
class ProjectHelperChatConfigResponse(BaseModel):
    model_name: str # 模型名称
    base_url: str # 基础URL
    api_key: str # API密钥
    user_prompt: str # 用户提示

class ProjectHelperChatConfigRequest(BaseModel):
    model_name: str # 模型名称
    base_url: str # 基础URL
    api_key: str # API密钥
    user_prompt: str # 用户提示

class ProjectHelperResourcesResponse(BaseModel):
    resource_name:list[str] # 资源名称列表
    enabled:bool # 是否启用
    
class ProjectHelperResourcesRequest(BaseModel):
    resource_name:list[str] # 资源名称列表
    enabled:bool # 是否启用
    
SSE约定
    "id":"project_helper:session_id:timestamp"
    "event":"chat/end"
    "data":{
        message_chunk:str
    }
    "retry": 30000 # 重试时间, 单位毫秒



```

## 7. 统一数据库设计 (Database Schema)

> **说明**: 
> 1. 本项目使用 `SQLModel` (基于 SQLAlchemy + Pydantic) 定义数据库模型。
> 2. Agent 的运行状态（State/History）由 **LangGraph Checkpointer** 自动托管（通常涉及 `checkpoints`, `checkpoint_writes` 等表），**无需**在此处手动定义。
> 3. 这里的模型主要关注：业务实体、插件配置、资源关系以及“信箱”通知系统。

### 7.1 核心基础 (Core & Plugin)

```python
class PluginSQLEntity(SQLModel, table=True):
    """
    插件注册表: 定义系统中所有可用的插件（能力）。
    """
    __tablename__ = "plugin"

    id: UUID = Field(default_factory=create_uuid, primary_key=True, description="插件ID")
    name: str = Field(index=True, unique=True, description="插件名称")
    description: Optional[str] = Field(default=None, description="插件描述")
    
    # 插件类型与作用域
    from_type: PluginFromEnum = Field(default=PluginFromEnum.system, description="来源: system(系统内置), custom(用户自定义)")
    scope_type: PluginScopeEnum = Field(default=PluginScopeEnum.work, description="作用域: global(全局), work(作品级), document(文档级)")
    
    # 全局开关
    enabled: bool = Field(default=True, description="全局启用状态")
    
    # 配置定义 (Schema) 与 默认配置
    # 存储 JSON 数据，例如 {"api_key": "string", "broadcast": "boolean"}
    config_schema: Dict = Field(default={}, sa_column=Column(JSON), description="配置Schema定义")
    default_config: Dict = Field(default={}, sa_column=Column(JSON), description="默认配置值")
    
    tags: List[str] = Field(default=[], sa_column=Column(JSON), description="标签列表")

    create_at: datetime = Field(default_factory=get_now_time, sa_type=TIMESTAMP(timezone=True))
    update_at: datetime = Field(default_factory=get_now_time, sa_type=TIMESTAMP(timezone=True))
    
    # Relationships
    work_mappings: List["WorkPluginMappingSQLEntity"] = Relationship(back_populates="plugin")


class WorkSQLEntity(SQLModel, table=True):
    """
    作品表: 项目的核心实体（如一本小说）。
    """
    __tablename__ = "work"

    id: UUID = Field(default_factory=create_uuid, primary_key=True, description="作品ID")
    
    name: str = Field(default="未命名作品", description="作品名称")
    cover_image_url: Optional[str] = Field(default=None, description="封面图片URL")
    summary: Optional[str] = Field(default=None, description="作品简介")
    
    # 作品类型，对应某种 WorkType 插件的标识
    work_type: WorkTypeEnum = Field(default=WorkTypeEnum.novel, description="作品类型标识")
    
    state: WorkEnum = Field(default=WorkEnum.updating, description="状态: updating, completed")
    
    create_at: datetime = Field(default_factory=get_now_time, sa_type=TIMESTAMP(timezone=True))
    update_at: datetime = Field(default_factory=get_now_time, sa_type=TIMESTAMP(timezone=True))

    # Relationships
    plugin_mappings: List["WorkPluginMappingSQLEntity"] = Relationship(back_populates="work")



class WorkPluginMappingSQLEntity(SQLModel, table=True):
    """
    作品-插件关联表: 记录某个作品启用了哪些插件，以及特定的配置。
    例如：某本小说开启了“历史考据助手”插件，并配置了特定的 Prompt。
    """
    __tablename__ = "work_plugin_mapping"

    id: UUID = Field(default_factory=create_uuid, primary_key=True)
    
    work_id: UUID = Field(foreign_key="work.id", index=True)
    plugin_id: UUID = Field(foreign_key="plugin.id", index=True)
    
    # 该作品下是否启用
    enabled: bool = Field(default=True)
    
    # 实例配置: 覆盖 Plugin 的 default_config
    # 关键点: Agent 的 "broadcast" (信箱通知) 开关通常在此配置
    # e.g., {"broadcast": true, "model": "gpt-4"}
    config: Dict = Field(default={}, sa_column=Column(JSON), description="作品级配置覆盖")
    create_at: datetime = Field(default_factory=get_now_time, sa_type=TIMESTAMP(timezone=True))
    update_at: datetime = Field(default_factory=get_now_time, sa_type=TIMESTAMP(timezone=True))
    
    # Relationships
    work: WorkSQLEntity = Relationship(back_populates="plugin_mappings")
    plugin: PluginSQLEntity = Relationship(back_populates="work_mappings")

```

### 7.2 Agent管理

```python
class AgentsManagerSQLEntity(SQLModel, table=True):
    """
    agent的管理模块
    """
    __tablename__ = "agents_manager"

    id:UUID = Field(default_factory=create_uuid, primary_key=True, description="agent的id")
    name:str = Field(description="agent的名称")
    description:str = Field(description="agent的描述")
    context_size : int, # 表示上下文的大小,单位token,若写入 -1 表示不做任何限制,因此也不会进行总结。0表示这个Agent没有历史记录的概念
    is_summary: bool, # 表示是否对上下文进行总结,在超出了上面的上下文大小之后
    enabled:bool
    broadcast:bool
    sessions:List[str] # 会话id列表
    config:Dict = Field(default={}, sa_column=Column(JSON), description="agent的配置")
    create_at:datetime = Field(default_factory=get_now_time, sa_type=TIMESTAMP(timezone=True))
    update_at:datetime = Field(default_factory=get_now_time, sa_type=TIMESTAMP(timezone=True))



```

### 7.3 内容与结构 (Content & Graph)

```python
class NodeSQLEntity(SQLModel, table=True):
    """
    节点表: 构成作品内容的原子单位（文档、文件夹、白板等）。
    """
    __tablename__ = "node"

    id: UUID = Field(default_factory=create_uuid, primary_key=True, description="节点ID")
    work_id: UUID = Field(foreign_key="work.id", index=True)
    
    name: str = Field(default="未命名节点")
    type: NodeTypeEnum = Field(description="类型: document, folder, whiteboard...")
    description: Optional[str] = None 
    create_at: datetime = Field(default_factory=get_now_time, sa_type=TIMESTAMP(timezone=True))
    update_at: datetime = Field(default_factory=get_now_time, sa_type=TIMESTAMP(timezone=True))

class NodeRelationshipSQLEntity(SQLModel, table=True):
    """
    节点关系表: 定义节点之间的非层级关系（如引用、链接）。
    支持网状叙事结构。
    """
    __tablename__ = "node_relationship"

    id: UUID = Field(default_factory=create_uuid, primary_key=True)
    work_id: UUID = Field(foreign_key="work.id", index=True)
    
    from_node_id: UUID = Field(foreign_key="node.id", index=True)
    to_node_id: UUID = Field(foreign_key="node.id", index=True) # 但是注意这里,是一个from_node_id对应多个to_node_id,是一对多所以有多条记录

class DocumentVersionSQLEntity(SQLModel, table=True):
    """
    文档版本表: 存储 Node (类型为 document) 的实际内容历史。
    """
    __tablename__ = "document_version"

    id: UUID = Field(default_factory=create_uuid, primary_key=True)
    node_id: UUID = Field(foreign_key="node.id", index=True)
    
    full_text: str = Field(default="", description="文档内容 (HTML/JSON/Markdown)")
    word_count: int = Field(default=0)
    version: int = Field(default=1, description="版本号，每次更新+1")
    create_at: datetime = Field(default_factory=get_now_time, sa_type=TIMESTAMP(timezone=True))
    update_at: datetime = Field(default_factory=get_now_time, sa_type=TIMESTAMP(timezone=True))



```

### 7.4 知识库(Knowledge)(插件)

```python
class KnowledgeBaseSQLEntity(SQLModel, table=True):
    """
    知识库元数据表
    """
    __tablename__ = "knowledge_base"
    
    id: UUID = Field(default_factory=create_uuid, primary_key=True)
    work_id: UUID = Field(default=None, index=True, description="关联作品ID")
    title: str = Field(description="知识库标题")
    description: Optional[str] = None
    enabled:bool = Field(default=True, description="该知识库是否启用")
    create_at: datetime = Field(default_factory=get_now_time, sa_type=TIMESTAMP(timezone=True))
    update_at: datetime = Field(default_factory=get_now_time, sa_type=TIMESTAMP(timezone=True))

class KnowledgeChunkSQLEntity(SQLModel, table=True):
    __tablename__ = "knowledge_chunk"
    
    id: UUID = Field(default_factory=create_uuid, primary_key=True)
    kb_id: UUID = Field(foreign_key="knowledge_base.id", index=True)
    context: str = Field(description="文本内容")
    search_keys: List[str] = Field(default=[], sa_column=Column(JSON), description="搜索关键词列表")
    enabled:bool = Field(default=True, description="该知识点是否启用")
    create_at: datetime = Field(default_factory=get_now_time, sa_type=TIMESTAMP(timezone=True))
    update_at: datetime = Field(default_factory=get_now_time, sa_type=TIMESTAMP(timezone=True))


```

### 7.5 记忆库(Memory)(插件)

```python
class MemorySQLEntity(SQLModel, table=True):
    """
    知识库元数据表
    """
    __tablename__ = "memory"
    
    id: UUID = Field(default_factory=create_uuid, primary_key=True)
    name: str
    description: Optional[str] = None
    enabled:bool = Field(default=True, description="该记忆是否启用")
    type:MemoryTypeEnum = Field(default=MemoryTypeEnum.vector, description="记忆类型")
    context:str
    create_at: datetime = Field(default_factory=get_now_time, sa_type=TIMESTAMP(timezone=True))
    update_at: datetime = Field(default_factory=get_now_time, sa_type=TIMESTAMP(timezone=True))

### 7.6 作品类型(WorkType)
class WorkTypeSQLEntity(SQLModel, table=True):
    """作品类型表."""
    __tablename__ = "work_type"

    id: str = Field(default_factory=create_uuid, primary_key=True)
    name: str = Field(unique=True, index=True)
    enabled: bool = Field(default=True)
    
    tags: List[str] = Field(default=[], sa_column=Column(JSON))
    relationship: List[str] = Field(default=[], sa_column=Column(JSON))
    configurable: bool = Field(default=False)
    
    create_time: datetime = Field(default_factory=get_now_time, sa_type=TIMESTAMP(timezone=True))


```
## 插件配置信息,以下这些是插件表中的结构
ps: 关于知识库和记忆插件之间的差距
1. 系统中的任何的Agent对知识库都只有读的操作,而没有主动写入知识库的权限。
2. 系统中的任何的Agent对记忆都只有被动加载而无主动读的功能,但是可以自行写入记忆。
3. 知识库面向的用户可以配置,记忆面向的是Agent可以配置,尽管对于用户都说都是可读写的。
4. 知识库是作品级别的,也就是不同作品之间有知识库隔离,而记忆是全局的,所有的Agent都可以访问到,在不同的作品中都生效。
### 知识库插件配置信息(在数据库中)
id:00000000-0000-0000-0000-000000000001
name:knowledge_plugin
description:知识库插件配置信息,你可以针对你的某个作品进行知识库的配置,注意:每个作品的知识库都是独立隔离的。
from_type: PluginFromEnum.SYSTEM
scope_type: PluginScopeEnum.WORK
enabled: true # 默认开启。这个规定了项目使用允许使用知识库
config_schema:{
  id: UUID
  work_id:UUID
  title: str 
  description: str
  create_at: datetime 
  enabled:bool # 这个规定了,某个指定的知识库是否开启
  chunks:[
    {
      name: str
      content: str
      search_keys: List[str]
      enabled:bool # 这个规定了,某个片段是否开启
      create_at: datetime
    }
  ]
}
  default_config:{} # 无默认配置
  tags:["Tool"] # 知识库插件

### memory插件配置信息(在数据库中)
id:00000000-0000-0000-0000-000000000002
name:memory_plugin
description:记忆插件配置信息,记忆是全局的,并且会直接加载到所有的Agent中。您可以直接传入记忆,但是推荐不要太多。系统会对记忆的内容进行自动的整理。
from_type: PluginFromEnum.SYSTEM
scope_type: PluginScopeEnum.GLOBAL
enabled: false # 默认关闭。
config_schema:{
  id: UUID
  name: str
  type: MemoryTypeEnum
  enabled:bool # 这个规定了,某个指定的记忆是否开启, 若关闭了,则系统不会自动处理这段记忆。
  description: str
  context:str # 记忆正文
  create_at: datetime 
}
  default_config:{} # 无默认配置
  tags:["Tool"] # 记忆插件

### 作品类型管理(没有enable表示不可以关闭)
id:UUID = 00000000-0000-0000-0000-000000000003
name: 作品类型管理
description: 作品类型管理,可以配置整个项目运行时候支持怎么样的作品类型。系统提供的类型一般不可修改,用户自定义的可以修改。
from_type: PluginFromEnum.SYSTEM
scope_type: PluginScopeEnum.GLOBAL
config_schema:{
    [
        {
            id: UUID,
            work_type: str,
            node_tags: List[str]
            relationship: List[dict[str, str]]
            configurable:bool # 这个规定了,某个指定的作品类型是否可以配置,一般来说添加的,自己定义的可以配置,系统提供的一般不可以配置。
        }
    ]
}
default_config:{
    [
        {
            id:  00000000-0000-0000-0000-000000000001,
            work_type: WorkTypeEnum.NOVEL, # 小说类型
            node_tags: ["document","folder"] # 小说类型的节点标签
            relationship: [{"folder":"document"}] # 小说类型的节点关系,这里表示文件夹可以包含文档,但是文档不能包含文件夹。并且文件夹不能包含其他的文件夹。
            configurable:false  # 不可以配置。
        }
    ]
} # 无默认配置
tags:[] # 系统插件

### Agent管理插件
id:UUID = 00000000-0000-0000-0000-000000000004
name: Agent管理插件
description: Agent管理插件,用于管理Agent的元信息,这个插件会自动扫描tag中含有"Agent"的Agent,将其注册到系统中。并进行数据结构的检测。至少需要包含字段在其config_schema中,[context]
from_type: PluginFromEnum.SYSTEM
scope_type: PluginScopeEnum.GLOBAL
config_schema:
    agents:[
        {
            id: UUID,
            name: str,
            context_size : int, # 表示上下文的大小,单位token,若写入 -1 表示不做任何限制,因此也不会进行总结。0表示这个Agent没有历史记录的概念
            is_summary: bool, # 表示是否对上下文进行总结,在超出了上面的上下文大小之后
            description: str,
            sessions:list[str]
            enabled:bool # 这个规定了,某个指定的Agent是否开启
            broadcast:bool,# 表示是否开启通知功能(和决定在筛选的时候,在全部的模式下,能不能显示这个Agent的消息)
        }
    ]
default_config:{
    agents:[
        {
            id:  00000000-0000-0000-0000-000000000001,
            name: 项目助手,
            context_size : 24000
            is_summary: false,
            description: 用于辅助用户了解整个项目的Agent,
            enabled:true 
            broadcast:false
        },
        {
            id:  00000000-0000-0000-0000-000000000002,
            name:小说创作助手,
            context_size : 50000
            is_summary: true,
            description: 用于辅助用户创作小说的Agent,
            enabled:true 
            broadcast:true
        }
    ]
}
tags:[]

### 项目助手
id:UUID = 00000000-0000-0000-0000-000000000005
name: 项目助手
description: 项目助手,用于辅助用户了解整个项目的Agent,
from_type: PluginFromEnum.SYSTEM
scope_type: PluginScopeEnum.GLOBAL
config_schema:
    name: str # 上面那个是插件的名字,这个是自定义的Agent的名
    model_name: str # 表示使用的模型的名字
    base_url:str # 表示模型的base_url
    api_key:str # 表示模型的api_key
    user_prompt:str # 表示用户的系统提示词
    tools:dict[str,str] # 表示工具的信息,key表示工具的名字,value表示工具的描述,每个工具都是一个插件,插件的tag中必须包含"Tool",若没有描述,则取插件的默认描述,key为插件的name
default_config:{
    tools:{
        "memory":null
    }
}



### 文档创作助手
id:UUID = 00000000-0000-0000-0000-000000000006
name: 文档创作助手
description: 文档创作助手,用于辅助用户创作文档的Agent,
from_type: PluginFromEnum.SYSTEM
scope_type: PluginScopeEnum.DOCUMENT
config_schema:
    name: str # 上面那个是插件的名字,这个是自定义的Agent的名
    model_name: str # 表示使用的模型的名字
    base_url:str # 表示模型的base_url
    api_key:str # 表示模型的api_key
    user_prompt:str # 表示用户的系统提示词
    tools:dict[str,str] # 表示工具的信息,key表示工具的名字,value表示工具的描述,每个工具都是一个插件,插件的tag中必须包含"Tool",若没有描述,则取插件的默认描述,key为插件的name,建议工具的插件name为英文的方式。
default_config:{
    tools:{
        "memory":null,
        "document":null
    }
}


       